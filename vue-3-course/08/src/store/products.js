export default {
	namespaced: true,
	// 12.4 Стейт делаем пустым массивом на старте
	state: {
		items: []
	},
	// ? 12.6.0 Здесь особо следует заметить некоторые моменты, связанные с асинхронностью — приложение отображается сразу, а товары с сервера приходят чуть позже, то возможны некоторые странные ситуации. Например, есть страница товара и до загрузки информации о нём успевает промелькнуть компонент страницы ошибки 404. Так выходит потому, что когда мы страницу отображаем, то сперва у нас срабатывает геттер "one", получающий товар по id, а товаров у нас пока ещё нет, а значит он возвращает нам undefined и computed-поле комп. "Product" "hasProduct" возвращает false. Поэтому отображается комп. E404. Затем данные с товарами загрузились и товар отобразился. Но это ещё ничего, гораздо хуже то, что может произойти в корзине.
	// Go to [vue-3-course\08\src\store\cart.js]
	// ? 12.7.0 Какой путь использования лоадеров — мы ставим в модуле товаров спец. геттер, который называется loaded и он будет сравнивать, что items != null. Тоже самое и в корзине (да и везде, где нужно). И компоненты с подобными маркерами-лоадерами теперь должны смотреть на то, нужны ли им эти данные или нет и если из компонента "Product" товары ещё не загружены, то он отобразит анимацию лоадера.
	// ? 12.7.1 Этот путь кажется предпочтительным, т.к. сайт загружается быстрее, но более проблематично с точки зрения написания логики, т.к. нужно продумать все компоненты, где нужен такой лоадер.
	// ? 12.7.2 В нашем случае для простоты поступим следующим образом: товары объявим критически важными данными, а корзина будет грузиться постфактум. В реальной практике комбинируют эти подходы и критические данные тоже могут быть в системе, но их должно быть мало. И зависит всё от проекта и его объёмов: если делаем небольшой интернет-магазин (100-200, может 1000 товаров), то товары можно класть в критические данные, как мы делаем сейчас. И чтобы сэкономить с запросом на сервер их можно с HTML-ответом отдавать. Но если представить какой-то огромный магазин или интернет-портал, то там конечно это делать уже недопустимо (но это уже совсем другой уровень подготовки).
	// Go to [vue-3-course\08\src\store\cart.js]
	getters: {
		all: state => state.items,
		one: state => id => state.items.find(item => item.id === id),
	},
	// 12.5.0 А также нам нужна будет мутация "setItems", которая примет стейт и список товаров и фиксирует в стейте эти товары
	mutations: {
		setItems(state, products) {
			state.items = products;
		}
	},
	// * 12.0 Про взаимодействие Vue JS с сервером. К самой API обращаться не составляет сложности, здесь хватит пары строк кода, но сложнее другое — работа с серверным API приносит в проект асинхронность. И т.о. те же товары, что до сих пор появлялись в системе сразу, то теперь они появляются в системе не сразу, а когда сервер нам их передаст. А мы например пытаемся сразу на странице одного товара его по id пытаемся найти. Но мы можем это несколько упростить — товары сделаем критически важными данными, а корзину будем загружать асинхронно.
	// 12.1 Итак, у нас есть уже тестовый массив с корзиной и нам нужно его где-то подгрузить динамически. Чтобы загрузить товары сделаем спец. экшен "load" и поместим в него метод fetch. Чтобы дожидаться полного завершения асинхронной операции, перед тем как дальше как-то использовать эти данные, нужно сделать экшен асинхронным и поставить ключевые слова "async" & "await".
	// Go to [vue-3-course\08\src\main.js]
	// 12.3 Также надо распаковать данные в читаемый JS формат, при помощи метода json. ↑
	// 12.5.1 Ну и, конечно, следует запустить мутацию 'setItems' для её вызова. ↑
	actions: {
		async load({ commit }) {
			let response = await fetch('http://faceprog.ru/reactcourseapi/products/all.php');
			let products = await response.json();
			// console.log(products); // И вот мы уже видим привычный массив объектов, с которым можно работать
			commit('setItems', products);
		}
	}
}