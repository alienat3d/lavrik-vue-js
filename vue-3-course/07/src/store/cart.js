// * 8.0 А теперь самое сложное из урока модуль корзины. Итак, в стейте "items" у нас будет лежать структура данных, где будет храниться айдишник товара и кол-во товара. Как нам написать код, чтобы было всё максимально быстро и эффективно? Все традиционно начинают писать код с мутаций и экшенов, т.к. если их не сделать, то массив "items" останется пустым. Но когда мы начинаем писать код с них, то в массив "items" мы будем пушать какую-то информацию и сходу не можем прочувствовать достаточно там данных или нет, правильная структура выбрана или неправильная. Например, решая эту задачу, можно написав мутацию/экшен addToCart сделать так, что в массив "items" из мутаций пушится просто айди товара, а затем выяснится, что этого недостаточно, потому, что нам нужно ещё и cnt (количество) хранить. И вот тут есть такой подход, который для новичков может показаться совершенно неочевидным. Не надо сразу реализовывать часть, связанную с администрированием сущности. Надо просто написать сперва данные заглушки, mutations, actions, а затем продумать state и getters. А потом на основе заглушек сделать так, чтобы нашим компонентам было удобно с этим работать, а уже потом, когда мы это оттестировали, то переходим к написанию мутаций и экшенов. 
export default {
	namespaced: true,
	state: {
		// 8.1 И вот мы начинаем планировать структуру данных, что сюда будет попадать товар, который в корзине лежит с айди и количеством "cnt"
		items: [
			{ id: 100, cnt: 1 },
			{ id: 103, cnt: 2 }
		]
	},
	// 8.2 Далее, выводя список товаров, мы можем сделать геттер, который будет проверять лежит такой товар в корзине или не лежит. Сделаем геттер "inCart", который примет стейт и будет определять в корзине товар или не в корзине.
	// Go to [vue-3-course\07\src\components\ProductsList.vue]
	// 8.4 И мы могли бы вернуть "state.items.length" (кол-во товаров в корзине), но нам это не нужно, а нужно нам понять лежит ли конкретный товар в корзине или нет. И вот правильная механика будет следующей: из геттера надо вернуть функцию, которая будет принимать id товара. Потому, что геттер запускаем не мы, а он запускается Vuex автоматически при изменении стейта и туда не приходит ничего, кроме стейта, геттера, рутстейта и рутгеттера.
	getters: {
		/* inCart(state) {
			return state.items.length
		}, */
		// 8.5.0 Но мы можем из этого геттера вернуть функцию, а внутри неё мы уже можем делать всё, что угодно. Потому, что эта функция примет от нас любой параметр, который мы захотим, а второе, что очень важно — она видит также переменную state, потому, что она объявлена в этой зоне видимости и видит её по замыканию. И вот, когда базовое состояние меняется, Vuex перезапустит все геттеры и в шаблон возвращается новая функция, которая видит обновлённый объект стейт по замыканию. И может смущать, что мы функцию заново пересоздаём, но это не страшно совершенно — старая функция удаляется, объект стейт — это один и тот же объект, он берётся по ссылке, т.ч. об излишнем потреблении памяти можно не волноваться.
		/* inCart(state) {
			return function (id) {
				return state.items.some(item => item.id == id)
			}
		}, */
		// 8.5.1 Тоже самое, что описано выше можно записать сокращённо так (именно такой вид можно встретить в офиц. документации). Как получается такая запись? Итак, мы знаем, что если стрелочная функция принимает 1 параметр и возвращает сразу результат, то можно также избавиться от фигурных скобок. Также и первую функцию сохраняем до стрелочной и убираем скобки круглые и фигурные, а также оператор return.
		// 8.5.2 И здесь геттер "inCart" генерируется автоматически и возвращает функцию в компонент, которая принимает id и возвращает результатом "state.items.some(item => item.id == id)".
		// Go to [vue-3-course\07\src\components\ProductsList.vue]
		inCart: state => id => state.items.some(item => item.id == id),
		// 8.13.0 Сама корзина может иметь ещё геттер "length", которая будет считать кол-во товаров и выводить это кол-во в вёрстку.
		// Go to [vue-3-course\07\src\App.vue]
		length: state => state.items.length,
		// total: (state, getter, rootState, rootGetters) rootGetters 
	},
	// 8.7 И только теперь есть смысл перейти к мутациям и экшенам, потому, что мы убедились, что выбранная нами структура данных адекватно работает и может быть применена в компонентах и т.д.
	// 8.8 Первой мутацией у нас будет "add", добавление товара в корзину. Она будет принимать стейт и айдишник товара и пушать его в стейт корзины, как новый объект с этим айдишником и cnt равным по умолчанию единице.
	// 8.9 Мутация "remove" у нас будет заниматься обратным действием "add" т.е. удалению товара из корзины и также примет стейт и id товара. Теоретически мог бы принимать номер элемента в массиве, но вместо этого мы можем ориентируясь на id вызвать функцию фильтра для state.items. Это будет даже лаконичнее, чем делать поиск индекса, а потом применять splice (как возможное решение). И запишем, что у артикля айдишник должен отличаться от переданного, иначе объект с этим айдишником из массива вылетает (как и товар из корзины).
	total: (state, getters, rootState, rootGetters) => state,
	mutations: {
		add(state, id) {
			state.items.push({ id, cnt: 1 });
		},
		remove(state, id) {
			state.items = state.items.filter(item => item.id != id);
		}
	},
	// 8.10.0 В экшенах у нас будут пока не слишком осмысленные обёртки над "add" & "remove". Не слишком осмысленные, потому, что нет никакой асинхронности. На следующем уроке асинхронность придёт и реалистичность экшенов станет выше. В экшенах принимаем доступ к мутации "commit", а также id. После чего мы используем commit и прокидываем в него название мутации и id далее. Тоже самое будет и с "remove".
	// Go to [vue-3-course\07\src\components\ProductsList.vue]
	// 8.11 Нам нужно также продумать ситуацию, когда у нас появится асинхронность, а вместе с ней какой-то временной лаг, пока данные уходят на сервер, чтобы пользователь не мог добавлять много одинаковых объектов товара в корзину, думая, что его первый клик не сработал и также не пытался удалить уже несуществующий в корзине товар. И, с этой точки зрения, наши экшены могут принимать не только "commit", но и "getters", чтобы сделать проверку, что, в случае с "add" вызывать commit добавления товара только, если его ещё нет в корзине и с "remove" соответственно наоборот.
	// ? 8.12 В реальных проектах, когда мы имеем дело с асинхронностью, тут приходится чуть более заморачиваться, добавляя ещё массив inProcess (?), потому, что если юзер нажал добавить в корзину, то перед тем, как товар реально в корзину попадёт всё равно будет некая задержка на время запроса на сервер, а кнопку нам нужно блокировать сразу, как только запрос на сервер ушёл. И вот в этот массив мы кладём айдишники товаров, а также делаем ещё один геттер inProcess и все товары, которые попадают в inProcess у них кнопки получают атрибут "disabled". ↑
	actions: {
		add({ commit, getters }, id) {
			if (!getters.inCart(id)) {
				commit('add', id);
			}
		},
		remove({ commit, getters }, id) {
			if (getters.inCart(id)) {
				commit('remove', id);
			}
		}
	}
}