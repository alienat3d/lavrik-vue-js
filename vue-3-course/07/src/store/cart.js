// * 8.0 А теперь самое сложное из урока модуль корзины. Итак, в стейте "items" у нас будет лежать структура данных, где будет храниться айдишник товара и кол-во товара. Как нам написать код, чтобы было всё максимально быстро и эффективно? Все традиционно начинают писать код с мутаций и экшенов, т.к. если их не сделать, то массив "items" останется пустым. Но когда мы начинаем писать код с них, то в массив "items" мы будем пушать какую-то информацию и сходу не можем прочувствовать достаточно там данных или нет, правильная структура выбрана или неправильная. Например, решая эту задачу, можно написав мутацию/экшен addToCart сделать так, что в массив "items" из мутаций пушится просто айди товара, а затем выяснится, что этого недостаточно, потому, что нам нужно ещё и cnt (количество) хранить. И вот тут есть такой подход, который для новичков может показаться совершенно неочевидным. Не надо сразу реализовывать часть, связанную с администрированием сущности. Надо просто написать сперва данные заглушки, mutations, actions, а затем продумать state и getters. А потом на основе заглушек сделать так, чтобы нашим компонентам было удобно с этим работать, а уже потом, когда мы это оттестировали, то переходим к написанию мутаций и экшенов. 
export default {
	namespaced: true,
	state: {
		// 8.1 И вот мы начинаем планировать структуру данных, что сюда будет попадать товар, который в корзине лежит с айди и количеством "cnt"
		items: [
			{ id: 100, cnt: 1 },
			{ id: 103, cnt: 2 }
		]
	},
	// 8.2 Далее, выводя список товаров, мы можем сделать геттер, который будет проверять лежит такой товар в корзине или не лежит. Сделаем геттер "inCart", который примет стейт и будет определять в корзине товар или не в корзине.
	// Go to [vue-3-course\07\src\components\ProductsList.vue]
	// 8.4 И мы могли бы вернуть "state.items.length" (кол-во товаров в корзине), но нам это не нужно, а нужно нам понять лежит ли конкретный товар в корзине или нет. И вот правильная механика будет следующей: из геттера надо вернуть функцию, которая будет принимать id товара. Потому, что геттер запускаем не мы, а он запускается Vuex автоматически при изменении стейта и туда не приходит ничего, кроме стейта, геттера, рутстейта и рутгеттера.
	// * 11.0 Приступаем к выполнению задания: вывести сводную таблицу, в которую попадают данные из двух модулей: данные о названии товара, его кол-ве в корзине и интерфейс для работы с этим товаром (кнопки "+", "-" и "remove"). И тут быстро становится ясно, что здесь нам нужны все данные: и данные из модуля товаров, где лежат "title", "price" и т.д., И данные из модуля корзины, показывающие какой в данный момент из товаров лежит в ней и в каком кол-ве. Для этого создадим геттер "itemsDetailed", а возвращать будем "items.map(item)"
	getters: {
		/* inCart(state) {
			return state.items.length
		}, */
		// 8.5.0 Но мы можем из этого геттера вернуть функцию, а внутри неё мы уже можем делать всё, что угодно. Потому, что эта функция примет от нас любой параметр, который мы захотим, а второе, что очень важно — она видит также переменную state, потому, что она объявлена в этой зоне видимости и видит её по замыканию. И вот, когда базовое состояние меняется, Vuex перезапустит все геттеры и в шаблон возвращается новая функция, которая видит обновлённый объект стейт по замыканию. И может смущать, что мы функцию заново пересоздаём, но это не страшно совершенно — старая функция удаляется, объект стейт — это один и тот же объект, он берётся по ссылке, т.ч. об излишнем потреблении памяти можно не волноваться.
		/* inCart(state) {
			return function (id) {
				return state.items.some(item => item.id == id)
			}
		}, */
		// 8.5.1 Тоже самое, что описано выше можно записать сокращённо так (именно такой вид можно встретить в офиц. документации). Как получается такая запись? Итак, мы знаем, что если стрелочная функция принимает 1 параметр и возвращает сразу результат, то можно также избавиться от фигурных скобок. Также и первую функцию сохраняем до стрелочной и убираем скобки круглые и фигурные, а также оператор return.
		// 8.5.2 И здесь геттер "inCart" генерируется автоматически и возвращает функцию в компонент, которая принимает id и возвращает результатом "state.items.some(item => item.id == id)".
		// Go to [vue-3-course\07\src\components\ProductsList.vue]
		inCart: state => id => state.items.some(item => item.id == id),
		// 8.13.0 Сама корзина может иметь ещё геттер "length", которая будет считать кол-во товаров и выводить это кол-во в вёрстку.
		// Go to [vue-3-course\07\src\App.vue]
		length: state => state.items.length,
		itemsDetailed: (state, getters, rootState, rootGetters) => {
			return state.items.map(item => {
				let product = rootGetters['products/one'](item.id) // ссылка на функцию получения товаров по id
				return { ...product, cnt: item.cnt } // добавляем к информации о продукте его количество
			})
		},
		/* 11.1 Описание, что происходит в геттере "itemsDetailed": допустим, что у нас в корзине лежит такая структура данных
		[
			{ "id": 100, "cnt": 1 }
			{ "id": 105, "cnt": 2 }
		]
		Далее запускается метод "map" по вышеозначенному массиву и на первой же итерации нам попадает первый объект и по его id'шнику возвращается описание этого товара, к которому прикрепляется его количество "cnt". В итоге возвращаемый массив выглядит таким образом:
		[
			{ "id": 100, "title": "Motorola Moto G Power", "price": 290, "rest": 10, "pic": "motorola-moto-g-power-2025.jpg", cnt: 1 }
			{ "id": 105, "title": "Sharp Aquos R9 pro", "price": 770, "rest": 7, "pic": "sharp-aquos-r9-pro.jpg", cnt: 2 },
		]
		Получается такое информационное слияние двух модулей. И, что важно, все эти запросы на получение товара по id происходят только 1 раз, когда мы перерасчитываем стейт. Дублирования данных не происходит. (Если бы мы в мутации на этапе записи данных в неё запихивали массив product, то данные бы лежали физически в двух разных местах, что являлось бы проблемой). Но здесь, при изменении стейта (не важно стейта корзины или товаров) "itemsDetailed" перерасчитывается полностью и обновятся автоматически.
		 */
		// 11.2 И теперь, с таким геттером "itemsDetailed" нам очень легко рассчитать "total" при помощи метода "reduce", т.е. общую сумму цены товаров. Он будет принимать "t" (total - переменная-аккумулятор итоговой суммы) & "i" (item - значение каждой итерации массива), а дальше умножаем цену товара на его кол-во и инициализируем нулём (первоначальное значение аккумулятора, к которому будут прибавляться остальные значения из массива).
		// Go to [vue-3-course\07\src\App.vue]
		total: (state, getters) => getters.itemsDetailed.reduce((t, i) => t + i.price * i.cnt, 0)
	},
	// 8.7 И только теперь есть смысл перейти к мутациям и экшенам, потому, что мы убедились, что выбранная нами структура данных адекватно работает и может быть применена в компонентах и т.д.
	// 8.8 Первой мутацией у нас будет "add", добавление товара в корзину. Она будет принимать стейт и айдишник товара и пушать его в стейт корзины, как новый объект с этим айдишником и cnt равным по умолчанию единице.
	// 8.9 Мутация "remove" у нас будет заниматься обратным действием "add" т.е. удалению товара из корзины и также примет стейт и id товара. Теоретически мог бы принимать номер элемента в массиве, но вместо этого мы можем ориентируясь на id вызвать функцию фильтра для state.items. Это будет даже лаконичнее, чем делать поиск индекса, а потом применять splice (как возможное решение). И запишем, что у артикля айдишник должен отличаться от переданного, иначе объект с этим айдишником из массива вылетает (как и товар из корзины).
	// total: (state, getters, rootState, rootGetters) => state,
	// 11.6 Одноимённая мутация "setCnt" будет очень похожа на экшен по своему содержанию, только естественно первым параметром у неё будет стейт. И она находит товар с помощью "find" метода. И здесь можно даже не делать проверку на undefined, т.к. мы уверены, что такой товар найдётся, ведь он не запустится, пока не пройдёт проверка в экшене, что id товара уже есть в корзине.
	// Go to [vue-3-course\07\src\components\Cart.vue]
	// 11.9.1 В мутации setCnt мы также присвоим cnt item.cnt.
	mutations: {
		add(state, id) {
			state.items.push({ id, cnt: 1 });
		},
		remove(state, id) {
			state.items = state.items.filter(item => item.id != id);
		},
		setCnt(state, { id, cnt }) {
			let item = state.items.find(item => item.id === id);
			item.cnt = cnt;
		}
	},
	// 8.10.0 В экшенах у нас будут пока не слишком осмысленные обёртки над "add" & "remove". Не слишком осмысленные, потому, что нет никакой асинхронности. На следующем уроке асинхронность придёт и реалистичность экшенов станет выше. В экшенах принимаем доступ к мутации "commit", а также id. После чего мы используем commit и прокидываем в него название мутации и id далее. Тоже самое будет и с "remove".
	// Go to [vue-3-course\07\src\components\ProductsList.vue]
	// 8.11 Нам нужно также продумать ситуацию, когда у нас появится асинхронность, а вместе с ней какой-то временной лаг, пока данные уходят на сервер, чтобы пользователь не мог добавлять много одинаковых объектов товара в корзину, думая, что его первый клик не сработал и также не пытался удалить уже несуществующий в корзине товар. И, с этой точки зрения, наши экшены могут принимать не только "commit", но и "getters", чтобы сделать проверку, что, в случае с "add" вызывать commit добавления товара только, если его ещё нет в корзине и с "remove" соответственно наоборот.
	// ? 8.12 В реальных проектах, когда мы имеем дело с асинхронностью, тут приходится чуть более заморачиваться, добавляя ещё массив inProcess (?), потому, что если юзер нажал добавить в корзину, то перед тем, как товар реально в корзину попадёт всё равно будет некая задержка на время запроса на сервер, а кнопку нам нужно блокировать сразу, как только запрос на сервер ушёл. И вот в этот массив мы кладём айдишники товаров, а также делаем ещё один геттер inProcess и все товары, которые попадают в inProcess у них кнопки получают атрибут "disabled". ↑
	// 11.5 Когда таблица свёрстана займёмся кнопками увеличения и уменьшения товара. Удобнее всего будет сделать реализацию через экшен "setCnt", который принимает id товара и новое кол-во. Добавим условие, что менять кол-во можно только, если товар уже есть в корзине. Ну и запускаем коммит, соответствующий мутации "setCnt", куда передаём этот же объект с id & cnt. ↑
	// 11.9.0 Ну и сделаем нашему счётчику товара валидацию, чтобы он не уходил в минусовые числа через метод Math.max(cnt, 1). И теперь, если число будет меньше 1, то оно заменится на 1. А методом min мы закроем остатком товара на складе "item.rest". Делаем это именно в экшене, а не в мутации, потому, что нам нужен доступ не только к стейту, но и к геттеру "itemsDetailed", чтобы узнать о кол-ве доступных товаров. И вот в "setCnt" нам тоже нужно получить из геттеров товар. А дальше мы валидируем cnt. ↑
	actions: {
		add({ commit, getters }, id) {
			if (!getters.inCart(id)) {
				commit('add', id);
			}
		},
		remove({ commit, getters }, id) {
			if (getters.inCart(id)) {
				commit('remove', id);
			}
		},
		setCnt({ commit, getters }, { id, cnt }) {
			if (getters.inCart(id)) {
				let item = getters.itemsDetailed.find(item => item.id === id);
				let validCnt = Math.min(Math.max(cnt, 1), item.rest); // ? Если item.rest = 4, а попадает сюда 3, то в Math.max() между 3 и 1 выбирается максимальное значение 3, а в Math.min() между 3 и 4 берётся минимально 3 и оно принимается. Если придёт 0, то в Math.max() будет выбрана 1 и взята 1. А если придёт число 100, то в Math.max() будет взято между 100 и 1 - 100, а между 100 и 4 — 4. Таким образом значение никогда не выбивается за диапазон между 1 и числа в item.rest
				commit('setCnt', { id, cnt: validCnt })
			}
		}
	}
}