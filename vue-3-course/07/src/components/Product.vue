<template>
  <div>
    <div v-if="hasProduct" class="text-center">
      <h1>
        <!-- {{ $store.getters['products/one']($route.params.id).title }} -->
        {{ product.title }}
      </h1>
      <hr />
      <img class="my-4" :src="'/img/products/' + product.pic" />
      <div class="price mb-5">
        <!-- $ {{ $store.getters['products/one']($route.params.id).price }} -->
        $ {{ product.price }}
      </div>
      <button
        v-if="inCart(product.id)"
        @click="remove(product.id)"
        type="button"
        class="btn btn-danger d-block mx-auto mb-4"
      >
        Remove
      </button>
      <button
        v-else
        @click="add(product.id)"
        type="button"
        class="btn btn-success d-block mx-auto mb-4"
      >
        Add to cart
      </button>
      <div class="d-inline-block alert alert-success">
        Amount left in the store:
        <!-- 9.3.1 Везде меняем на более лаконичную запись через обращение к computed-полю "product". -->
        <!-- {{ $store.getters['products/one']($route.params.id).rest }} -->
        {{ product.rest }}
      </div>
      <!-- 5.1 Через $route.params мы обращаемся к айдишнику и теперь сюда будет выводиться значение введённое в адрес на месте id. Таким образом можно получить доступ к нужной информации о товаре по id, получаемом из адресной строки из раутера. -->
      <!-- Go to [vue-3-course\07\src\store\index.js] -->
      <!-- 9.1 А теперь можно начинать применять геттер, который только что создали в хранилище "products". Обратимся к нему через "$store.getters" и к его функции "one" и передадим туда id -->
      <!-- <div class="alert alert-success">
				price
				{{ $route.params.id }}
				{{ $store.getters['products/one']($route.params.id) }}
			</div> -->
    </div>
    <app-e-404 />
  </div>
</template>

<!-- 9.2 Начинаем создание computed-полей для страницы инфо одного артикля. Сперва импортируем mapGetters и помещаем его в computed с распаковкой из модуля "products". Далее возьмём геттер "one", которые переименуем в "productById". Теперь это функция "productById", которая находит и отдаёт объект товара по его id. -->
<!-- 9.3.0 Для удобства создадим computed поле "product", которое будет нам возвращать продукт, используя функцию "one" aka "productById". И вот теперь этот "product" можно использовать везде в шаблоне. ↑ -->
<!-- 9.4 Теперь, чтобы код был более правильным нужно использовать строгое сравнение при поиске товара, поэтому сделаем ещё одно computed-поле "id", где будет строчное значение id переводить в число и уже его будем подставлять в метод "productById". -->
<!-- ? Во Vue computed-поля являются главной тактической силой и создавать много таких полей это очень удобно, потому что уменьшается кол-во действий в самом шаблоне и он становится меньше и лаконичнее. -->
<!-- 9.5 Также при помощи поля "hasProduct" проверим существует ли такой товар. -->
<!-- 9.6 Но теперь, при использовании перевода id в числовой тип данных мы сталкиваемся с таким багом, что можно будет набрать в адресной строке что-то вроде ".../101abc" и это сработает, т.к. буквы после цифр будут отсекаться. Также, если использовать "+" или "Number", то будут проходить ссылки вида: ".../000101" или ".../+101", поэтому стоит добавить ещё одну проверку, которая будет называться "validId" и она будет проверять простой регуляркой корректность переданного id. -->
<!-- 9.7 Рассмотрим на примере поля "price" ещё один важный нюанс. Представим, что мы из "product" делаем какие-то computed-поля, например "price" (это конечно уже перебор, ведь явно проще в шаблоне написать "product.price") и если так сделать, то уже возникает лёгкая тревога за этот код. Ведь "product" может быть в значении "undefined" (если id не найден), а в поле "price" мы берём у "product" ключ "price". Так вот, это может стать проблемой, а может и не стать. Всё зависит от того как аккуратно будет написан код: computed-поля не рассчитываются до первого доступа к ним откуда-то ни было. И если мы в шаблоне вывод div'а, который использует computed-поле "price", закроем директивой v-if="hasProduct", то если этот блок не рендерится, потому, что товара нет, то и computed-поле "price" не задействовано и нам не нужно бояться ошибок. -->
<!-- * 10.0 Теперь, что касается 404 ошибки, гораздо более логично, чтобы она показывалась на той же странице без редиректа. Потому, что так пользователю понятно где он ошибся, т.к. он может посмотреть на адрес, что он ввёл, а после редиректа он будет видеть другой адрес. Плюс это ещё важно для поисковых роботов. И никто не запрещает в любом компоненте подключить компонент страницы 404 и в нём же вывести. -->
<!-- ? 10.1 Если стартовать Vue с включёнными настройками Vue-router & Vuex, то создаётся такая система папок, что есть отдельно components (переиспользуемые компоненты) и отдельно views (компоненты страниц). Разделение это больше концептуальное, хоть и внешне они друг от друга не отличаются. Тогда можно сделать компонент E404, который в виде параметров принимает заголовок и подзаголовок и сделать страницу 404. Здесь так усложнять не будем, а пока просто используем в этом компоненте другой компонент с ошибкой 404. -->
<!-- 10.2 Импортируем его сюда, переименовывая с префиксом "App", а затем вставляем в шаблон выше. ↑ -->
<!-- ? 10.3 Если когда-то понадобится сделать всё таки редирект на какую-то страницу с ошибкой (например отсутствие прав доступа и т.п.), то мы зарегистрируем ещё один раут со специфическим названием и редиректим на него пользователя (но это достаточно редкий случай). -->
<!-- Go to [vue-3-course\07\src\store\cart.js] -->
<script>
import { mapGetters } from 'vuex';
import AppE404 from './E404.vue';

export default {
  components: {
    AppE404,
  },
  computed: {
    ...mapGetters('products', { productById: 'one' }),
    ...mapGetters('cart', ['inCart']),
    id() {
      return parseInt(this.$route.params.id);
    },
    validId() {
      return /^[1-9]+\d*$/.test(this.id); // ? значение регулярки: всё, что не начинается с 0 отклоняется, а затем любое кол-во любых цифр включая 0.
    },
    product() {
      return this.productById(this.id);
      // return this.productById(this.$route.params.id);
    },
    /* price() {
      return this.product.price;
    }, однако, как было сказано, нам не нужно такое поле, оно здесь только лишь для примера */
    hasProduct() {
      return this.validId && this.product !== undefined;
    },
  },
};
</script>
<style scoped>
.price {
  font-size: 30px;
}
</style>
