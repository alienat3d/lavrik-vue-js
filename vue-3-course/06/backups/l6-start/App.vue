<!-- * 1.0 * VueX * Часто бывают ситуации, когда нам нужен доступ к одним и тем же данным из разных компонентов. До сих пор, рассмотренные прежде примеры были довольно локальны и такие данные в них отсутствовали. Там были всего два уровня вложенности и данные использовались локально. Но обычно бывает так, что у нас есть главный App компонент, который контролирует всё. И, допустим это какой-то небольшой интернет магазин, у которого есть корзина и карточки товаров. (см. скриншот 1) Есть некие данные о том, что именно и в каком кол-ве пользователь положил в корзину. От этого зависит то, что отображается в корзине и в кнопке у товара. И вот, если данные нужны сразу в двух местах сразу, то возникает в компонентном подходе следующий парадокс. Представим дерево компонентов (см. скриншот 2) и вот, чтобы Cart & CardItem видели одни и те же данные — необходимо, чтобы эти данные лежали у их общего родителя. И общим родителем является корневой App компонент. И если бы нам пришлось через все уровни вложенности прокидывать пропы и эмиты, то это был бы кошмар. -->
<!-- ? 1.1 Писать подобный код мы не будем, т.к. это не самое приятное занятие, но на словах в теории он будет выглядеть следующим образом: в App мы создадим какие-то данные и правила изменения этих данных. Т.е. в data у нас будет название товара и кол-во товара, а также создадим два метода increase & decrease. Также и в корзине для вывода total и в карточке товара для вывода кол-ва и цены товара нужны оба этих свойства и туда мы их передадим как пропы. В тоже время, когда мы кликнем по кнопке товара добавить товар, то этот компонент не сможет сам изменить кол-во товара, а ему придётся делать эмит, который поднимется в App, где кол-во поменяется. И на первый взгляд звучит не так уж и сложно, но надо понимать, что уровень вложенности тут может быть достаточно глубоким. В итоге у нас будет ситуация, что нам придётся сделать все компоненты между App & Cart, CardItem своего рода транзитными узлами, который опускают пропы и пробрасывают эмиты наверх. Также и логика компонентного подхода страдает, ведь компоненты должны быть более менее друг от друга изолированы. А также у нас будет всё больше и больше замусориваться корневой комп. App, который будет описывать всё происходящее на сайте. -->
<!-- ? 1.2 Папка l6-start специально была выделена, чтобы можно было попробовать этот подход и увидеть в какую непонятную «кашу» превращается код. -->

<!-- * 2.0 А что делать, чтобы этой «каши» не было? Создаётся некое хранилище "store", в котором хранятся только данные и логика их изменения. Любой компонент может получить к хранилищу доступ через поле объекта "this.$store", а в шаблоне "$store". И все данные, которые нужны в разных частях сайта (состояние корзины товаров, данные о пользователе или ещё какие-то глобальные данные) будут храниться именно в хранилище store, а не в компонентах. В комп. состояние в виде data может оставаться, но только, если этот компонент отвечает за что-то своё. Скажем, если есть форма, которую пользователь должен заполнить и отправить на сервер и больше эти данные нигде не используются, то они остаются в data. А если это, например, имя юзера, которое потом должно быть использовано ещё в шапке, подвале и т.д. то это уже должно быть во VueX. И теперь любой комп. может данные из store получить, не прокидывая через всю иерархию родительских комп., а также их поменять (но здесь есть ограничения). Если представить, что VueX это некий объект, описывающий состояния нашего приложения, то мы получаем некий аналог глобальной переменной. А к глобальным переменным в программировании относятся плохо, т.к. можно было бы случайно поменять её значение и это сильно сказывается на стабильности и безопасности приложения. Поэтому store есть значение state, которое read-only, а в дополнение расписываются функция или несколько функций, которые имеют право этот state менять (эти функции называют "мутации"). И когда какой-то компонент хочет поменять значение в state, то он обращается к нужной мутации. Мутация же в свою очередь полностью контролирует state (т.е. в ней могут быть какие-то проверки, что, например, товара не стало меньше 0 или что товара положили в корзину не больше, чем осталось на складе и т.д.). В одном месте прописывается вся логика работы с данными — текущее состояние "state" и возможные механики изменения этого состояния "мутации". -->
<!-- Go to [vue-3-course\06\src\store.js] -->
<template>
  <div>
    <app-header />
    <app-content />
  </div>
</template>

<script>
import AppHeader from './components/Header';
import AppContent from './components/Content';

export default {
  components: {
    AppHeader,
    AppContent,
  },
};
</script>
