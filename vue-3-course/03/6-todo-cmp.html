<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>1</title>
	<link href="../../vendor/css/bootstrap.min.css" rel="stylesheet">
	<link href="../../vendor/css/style.css" rel="stylesheet">
	<script src="../../vendor/js/vue.global.js"></script>
</head>
<!-- ? 1.7 Но насколько компонентный подход прекрасен при передаче пропсов от родительского дочернему компоненту, то он явно не вызовет энтузиазма, когда мы будем говорить об эвенте от дочернего родительскому. -->
<!-- ? 1.8 Но сразу надо условится, что компонентный подход это вещь неизбежная, в каком бы фреймворке мы не работали и он существует безальтернативно не потому, что он позволяет писать идеальный код, но потому, что пока ничего лучше него ещё не придумали. Это единственный нормальный способ масштабировать большую систему. -->

<body>
	<div class="wrapper">
		<div class="sample">
			<div class="Todo">
				<h1>Your actions</h1>
				<!-- * 2.0 Итак, переносим наше приложение "Трекер привычек" в компонентный подход. Сначала мы забываем об обратной связи от компонента (такое внегласное правило), т.е. про обработку каких-то кликов и т.д.. -->
				<!-- 2.7 Удостоверившись в том, что всё работает мы хотим теперь размножить эти компоненты по кол-ву полезных действий, что у нас есть в приложении. Делаем это с "v-for", а затем передаём все параметры динамически через ":". Не забудем и про атрибут "key", в который значением подставим "i", т.е. индекс итерации (хоть и не самый удачный ключ, но у наших компонентов нет настоящего id). ↓ -->
				<!-- 2.10.2 ...а родительский мы подпишем на это же событие "step". Главное, чтобы названия совпадали. И в это событие мы запишем метод "makeStep". ↓ -->
				<app-todo-action v-for="action,i in todoList" :key="i" :title="action.title" :value="action.current"
					:max="action.max" @step="makeStep(i)"></app-todo-action>
				<!-- ? 2.5 И вот здесь вроде бы пора распечатывать в вёрстке эти action’ы, а вроде мы ещё не готовы директивой v-for их выводить, да и кажется они сами до конца ещё не готовы в плане реализации. Но важно понимать, что система делается изнутри наружу. И чтобы дочерний компонент эффективно работал должен быть протестирован в вакууме. И мы сперва можем не торопясь в отрыве погонять его в отрыве от базового компонента вручную передавая туда параметры. Кстати, "value" & "max" у нас описаны как Number, поэтому передавать мы их обязаны через ":" (или v-bind) ↓ -->
				<!-- ? При тестах без парных тегов был глюк с отображением лишь 1-го компонента. -->
				<!-- 				<app-todo-action title="Hello" :value="4" :max="10"></app-todo-action>
				<hr>
				<app-todo-action title="Hello2" :value="6" :max="6"></app-todo-action>
				<hr>
				<app-todo-action title="Hello3" :value="1" :max="20"></app-todo-action> -->
			</div>
		</div>
	</div>
	<script>
		// ? 2.1 В нейминге компонента префикс "App" в начале, хоть и необязательное дело, но самописные компоненты часто принято так называть. У библиотечных компонентов префикс как правило связан с названием библиотеки ("B" у Bootstrap, "V" у Vuetify и т.д.). ↓
		// 2.3 Теперь подумаем какие пропсы будет принимать этот компонент. Но, вообще, если мы сперва скопируем вёрстку в поле "template", то оно будет служить нам подсказкой какие именно пропсы нам нужны. А также выкидываем из него всё, что ему не понадобится больше, будучи компонентом. Например ему не нужен цикл. У него пока нету классов. И др. И вот, очистив от всей динамики мы можем увидеть лучше, что именно ему нужно будет передавать в пропсах: это title, название действия, это будет строка и имеет смысл сделать required. А также нам понадобятся числа "value" & "max" для прогрессбара и функционала показа строчки "All done!".
		// 2.4 Теперь, когда пропсы есть — можно начать их выводить в template.
		let AppTodoAction = {
			props: {
				title: { type: String, required: true },
				value: { type: Number, required: true },
				max: { type: Number, required: true }
			},
			// 2.6 А теперь к приятной части: мы всю логику, что мучила нас раньше без компонентного подхода переносим в computed раздел. Сперва вернём отношение текущего значения к максимальному в "rel", а затем ещё 'progressStyles', где мы высчитаем процент заполнения прогрессбара, который мы добавим в template в :style прогрессбару. Ну и ещё нам понадобятся классы, где мы будем возвращать разные CSS-классы в зависимости от условий в alertClasses и эти классы мы будем подставлять div’у с классом "alert".
			computed: {
				rel() {
					return this.value / this.max;
				},
				progressStyles() {
					return { width: this.rel * 100 + '%' }
				},
				alertClasses() {
					return {
						'alert-danger': this.rel < 0.25,
						'alert-warning': this.rel >= 0.25 && this.rel < 0.75,
						'alert-success': this.rel >= 0.75
					}
				}
			},
			// 2.8 Теперь нам нужно обработать клик по кнопке "I make step!". Здесь нам нужен метод и назовём его step.
			// ? 2.9 Но проблема в том, что мы не можем в него просто записать "this.value++", потому, что пропсы изменять нельзя, они в режиме "только для чтения". Дело в том, что в компонентных фреймворках действует концепция «unidirectional data flow» ("однонаправленный поток данных"). Т.е. если у родительского тега есть какие-то данные, то он дочерним элементам отдаёт эти данные с помощью пропсов, но наоборот дочерний компонент родительскому передать данные не может. Однако мы можем уведомить родительский компонент о наступившем событии на уровне событийной модели (пример "верстальщик и инпут" 3 урок 2:08). Почему так происходит? Потому, что дочерний комп. не знает заранее где он будет применён.
			// 2.10.0 Во Vue есть специальный метод $emit («эмитировать/выпустить событие») ↓
			// 2.10.2 И вот дочерний компонент скажет своему родительскому "на мне наступило событие «step»"... Кстати, мы также могли бы здесь передавать какие-то данные, как в закомментированном примере и тогда они будут доступны в шаблоне по $event. И эмититься может любой тип данных и строка и объект и др. ↑
			methods: {
				step() {
					this.$emit('step'/* , { some: 'nz' } */);
				}
			},
			template: `
			<div class="action">
				<div class="alert" :class="alertClasses">
					<h2>{{ title }}</h2>
					<div class="progress">
						<div class="progress-bar" :style="progressStyles"></div>
					</div>
					<hr>
					<h3 v-if="value == max">All done!</h3>
					<button v-else @click="step" type="button" class="btn btn-primary">
						I make step!
					</button>
				</div>
			</div>`
		};

		// 2.2 Сразу регистрируем новый компонент в рамках корневого компонента в поле "components". Это будет означать, что в его шаблоне данный компонент будет виден. Кстати, можно также написать и строку с кебаб-кейсом. ↑
		Vue.createApp({
			components: {
				AppTodoAction
			},
			data: () => ({
				todoList: [
					{ title: 'First action', current: 0, max: 5 },
					{ title: 'Other work', current: 0, max: 10 },
					{ title: 'Some fun', current: 0, max: 7 }
				]
			}),
			// 2.10.3 И этот метод "makeStep" мы опишем здесь: он будет принимать индекс того действия на котором был вызван и в переменную попадёт это действие из списка todoList. И если атрибут "current" этого действия всё ещё ниже максимума, то увеличим его на 1.
			methods: {
				makeStep(i) {
					let action = this.todoList[i];

					if (action.current < action.max) {
						action.current++;
					}
				}
			}
		}).mount('.sample');

		// 2.10.1 В нативном JS это можно сравнить с:
		/*
			@click
			$emit('click')
	
			addEventListener('some')
			dispatchEvent(new Event('some'))

			И когда мы работаем с нативными HTML-тегами, то мы ориентируемся на нормальные названия событий, которые есть в документации, но как только мы создали дочерние компоненты, то названия компонентов мы уже придумываем сами. ↑
		*/

	</script>
</body>

</html>