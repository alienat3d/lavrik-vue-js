<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>1</title>
	<link href="../../vendor/css/bootstrap.min.css" rel="stylesheet">
	<link href="../../vendor/css/style.css" rel="stylesheet">
	<script src="../../vendor/js/vue.global.js"></script>
</head>

<body>
	<div class="wrapper">
		<div class="sample">
			<div class="Todo">
				<h1>Your actions</h1>
				<!-- 1.2 Здесь мы выводим заголовок действия. -->
				<div class="action" v-for="(action, i) in todoList">
					<div class="alert" :class="getActionClass(action)">
						<h2>{{ action.title }}</h2>
						<div class="progress">
							<div :style="{width: (action.current / action.max * 100) + '%'}" class="progress-bar">
							</div>
						</div>
						<hr>
						<!-- 1.4 Если дошли до максимума полезных действий на сегодня, то вместо кнопки будет выведено "All done!". -->
						<!-- ? 1.5 И вот всё выглядит вроде бы нормально и на данном этапе внедрение компонентного подхода только навредит. Потому, что придётся настраивать взаимодействие родительского компонента с дочерними, а это требует дополнительного кода. Но тут нам, например, говорят: «Надо, чтобы было красиво! Надо выводить прогрессбар, показывающий сколько человек выполнил % этого действия. А ещё нужно сам ".alert", где выводится <h2> красить в разные цвета, в зависимости от прогресса. Пока 1\3 не прошёл надо красить в красный, после 2\3 - жёлтый и третья часть будет зелёной.» В итоге мы получаем неприятное computed поле, где будет зависимость "current" от "max", назовём его "rel" (relation). Почему оно неприятно? Да потому, что от него очень многое зависит: цвет алёрта, ширина прогрессбара и хуже всего, что оно не может быть computed полем, т.к. computed это зависимость одних данных от других. Проблема в том, что ToDo-лист это массив и мы не знаем заранее сколько в нём элементов. И эта задача нормально решается как раз тогда, когда появляется дочерний компонент, который и берёт на себя все эти операции. И если мы захотим отказаться от компонентного подхода, то нам сразу придётся сильно замусоривать шаблон кодом, как формула выше в прогрессбаре. А также приходится создавать не концептуальную функцию "getActionClass", которая также, как и шаблон рассчитывает current / max и возвращает набор классов для этого элемента. Короче говоря, это всё конечно работает, но проблема в том, что такую простыню кода очень сложно поддерживать. -->
						<h3 v-if="action.current === action.max">All done!</h3>
						<!-- 1.3 Подписываемся на событие клик кнопки и передаём метод "makeStep" -->
						<button v-else type="button" class="btn btn-primary" @click="makeStep(i)">
							I make step!
						</button>
					</div>
				</div>
			</div>
		</div>
	</div>
	<script>
		// * 1.0 Сперва изучим данный пример кода, а потом перепишем его на компонентный подход. У нас есть ToDo-лист, но не совсем простой, а трекер полезных привычек, которые человек должен делать в течении дня несколько раз. У каждого из таких действий запланирована кнопка "+", которую юзер будет нажимать, отмечая каждое выполнение полезного действия. И нажатие на кнопку будет повышать параметр "current".
		// ? 1.6 К тому же надо помнить, что computed поля эффективно существуют только тогда, когда есть одна смысловая сущность и для неё эти поля рассчитываются. (если бы не было было массива ToDo’шек, а был было только одно действие, то создавалось бы одно computed поле под relation, одно под классы и одно под прогрессбар, а когда появляется массив множества однотипных единиц, то выясняется, что под них Computed поля уже не сделаешь)
		// Go to [vue-3-course\03\6-todo-cmp.html]
		Vue.createApp({
			data: () => ({
				todoList: [
					{ title: 'First action', current: 0, max: 5 },
					{ title: 'Other work', current: 0, max: 10 },
					{ title: 'Some fun', current: 0, max: 7 }
				]
			}),
			// 1.1 У нас также имеются некоторые методы. Первый из которых makeStep принимает номер действия (его индекс в массиве) и увеличивает "current" на 1, если "current" не превышает "max".
			methods: {
				makeStep(i) {
					let step = this.todoList[i];

					if (step.current < step.max) {
						step.current++;
					}
				},
				getActionClass(action) {
					let rel = action.current / action.max;

					return {
						'alert-danger': rel < 0.25,
						'alert-warning': rel >= 0.25 && rel < 0.75,
						'alert-success': rel >= 0.75
					}
				}
			}
		}).mount('.sample');

	</script>
</body>

</html>