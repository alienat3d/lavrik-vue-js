// * 1.0 Итак, что мы здесь видим: создаётся некий корневой компонент (далее - комп.) App, в который будут помещаться другие комп. Здесь для data мы использовали стрелочную функцию (далее - стрелка), чтобы сократить код, но не везде так можно делать. Например хуки жизненного цикла их нельзя делать через стрелку, потому, что далее может потребоваться контекст этого компонента. Или если мы в каком-то компоненте будем ориентироваться на пропсы (входные параметры для комп.), то нам также стрелка не подойдёт, т.к. будет важен контекст вызова. Однако здесь нет никакой работы с контекстом, поэтому здесь оправдано такое сокращение кода, а обернув {} в () получается, что мы просто возвращаем объект без слова return, иначе JS подумал бы, что мы возвращаем результат какой-то функции.
const app = Vue.createApp({
	/* 	data() {
			return {
				name: ''
			}
		} */
	data: () => ({
		name: '',
		firstName: '',
		lastName: '',
		showAlert: false
	}),
	// * 2.0 Т.к. написание кода в шаблоне может сильно разрастаться, а также, чтобы не повторять код, следует использовать методы и подставлять их.
	// 2.1 Сюда также следует дописать "this", чтобы не потерять контекст. Сказать, что мы именно у текущего компонента хотим поменять значение "name"
	// ? 2.2 В 95% случаев методы это обработка событий. Но иногда бывает, что метод так просто написан, чтобы запускаться в какой-то момент времени другим методом. Методы крайне редко вызываются в шаблоне при рендеринге этого шаблона.
	methods: {
		onInput(evt) {
			this.name = evt.target.value
		}
	},
	// * 3.0 "computed" - вычисляемые данные, которые зависят от других данных. А теперь запишем наш метод из [vue-3-course\01\js\04-script.js] здесь в виде поля computed, а в вёрстке уберём "()"
	// ? "computed" поля нужно максимально стараться сегментировать.
	// Go to [vue-3-course\01\06-computed-sale.html]
	// ? "computed" поле никогда не должно давать побочного эффекта, например попробовать присвоить переменной новое значение "this.a = 1" это ошибка. А также какие-то действия, связанные с внешним, например вызов alert и что-то подобное — тоже ошибка. Т.е. записываем их по принципу "pure functions" функционального программирования, т.е. т.о., чтобы они рассчитывали данные на основе других данных без побочных эффектов. Но для расчёта данных не используются "()", как в обычных функциях, а используется контекст через "this".
	computed: {
		fullName() {
			console.log(1);

			return (this.firstName + ' ' + this.lastName).trim();
		}
	}
})

// 1.1 После того, как мы сформировали комп. мы говорим ему контролировать элемент в разметке с классом "sample". При таком подходе система видит, что нет ключа "template" берёт innerHTML div’а с классом "sample". И на основе этого шаблона, по описанным в комп. данным рендерит его на страницу. 
const root = app.mount('.sample')