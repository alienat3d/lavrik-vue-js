<!-- * 1.0 Займёмся доработкой предыдущей версии приложения. ↓ -->
<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>1</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
	<link href="../styles.css" rel="stylesheet">
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<!-- ? 2.0 Итак, при работе с фреймворками мы стремимся как можно больше избегать ручных операций с DOM и за счёт этого получаем от фреймворка выгоду. Наша работа — данные, а система сама сделает остальное. Но есть одна проблема — не под всё в HTML есть декларативные атрибуты, как и во Vue не под всё есть директивы. Представим, что есть задача, при добавлении нового гостя нам нужно сфокусироваться на последнем инпуте этого гостя. Иногда такие задачи удаются выполнить силами HTML, но иногда нет. И если нет, то нам понадобится прямая ссылка на элемент DOM, чтобы вызвать на этом элементе команду focus. Или например нужно сфокусировать первое невалидное поле. Тут уже HTML не поможет. -->
<!-- 2.1 Попробуем сделать авто-фокус средствами Vue, чтобы осознать тему ref’ов. И хоть в HTML есть атрибут "autofocus", срабатывающий при загрузке страницы, но с добавленными компонентами, вроде гостей это уже не сработает, к тому же в SPA при виртуальном переходе на другую страницу также, поэтому сделаем авто-фокус на Vue. Vue даёт нам доступ к такому объекту, который называется $refs — это ссылки на какие-то узлы DOM. Конечно вручную (с querySelector) мы эти узлы DOM получать не должны, а вместо этого добавляем компоненту атрибут "ref" и придумываем ему название. ↓ -->

<body>
	<div class="wrapper">
		<h1 class="my-5 text-center">Register Form</h1>
		<div class="sample">
			<form v-if="!formDone" @submit.prevent="sendForm">
				<div class="form-group">
					<label for="first-name">First Name
						<!-- <input v-model.trim="user.firstName" id="first-name" type="text" class="form-control" autofocus> -->
						<input v-model.trim="user.firstName" id="first-name" type="text" class="form-control" ref="firstInput">
					</label>
				</div>
				<div class="form-group">
					<label for="last-name">Last Name
						<input v-model.trim="user.lastName" id="last-name" type="text" class="form-control">
					</label>
				</div>
				<div class="form-group">
					<label for="phone">Phone
						<input v-model.trim="user.phone" id="phone" type="phone" class="form-control">
					</label>
				</div>
				<div class="form-group">
					<label for="email">E-Mail
						<input v-model.trim="user.email" id="email" type="email" class="form-control">
					</label>
				</div>
				<div class="form-group">
					<label>Guests</label>
					<input @click="addGuest" type="button" class="btn btn-primary" value="+">
				</div>
				<div>
					<!-- 3.1 И вот, всё таки, давайте сделаем тот функционал, что и собирались вначале 2-го урока: нам нужно, чтобы при добавлении нового гостя фокус ставился на инпут последнего добавленного гостя. Мы можем добавить инпуту ref и назвать его "guests". И здесь также есть различия между 2 и 3 Vue. Во 2-ой нам система собрала бы сюда массив гостей, а 3-яя будет класть сюда только последний input. В 3-ей версии они от этого отказались, потому, что крайне редко кому-то нужен целый массив ref’ов, но оставили возможность в ref передать ссылку на функцию, которая будет сама этот массив собирать, но это логику просто нужно прописать. Это действительно редкая операция и если вдруг понадобится, то найти её можно в следующем вебинаре: (https://www.youtube.com/watch?v=c3yDiVRJ0n0) -->
					<!-- 3.2 Итак, мы ставим ref "guests", зная, что это будет последний инпут, который цикл v-for проходит. (на самом деле опытным путём выяснили, что в итоге всё равно собирает в массив объекта Proxy) ↓ -->
					<div v-for="g,i in guests" class="form-group">
						<!-- 1.2.2 И здесь тоже, плюс мы можем уже ссылаться не на guests[i], а просто на guest. Мы можем даже сделать код более лаконичным, т.к. работаем теперь не со строками, а с объектом, т.е. ссылочным типом данных -->
						<label @dblclick="removeGuest(i)" :for="`guest-${++i}`">Guest #{{ i }}
							<input v-model.trim="g.value" :id="`guest-${i}`" type="text" class="form-control" ref="guests">
						</label>
					</div>
				</div>
				<hr>
				<button :disabled="!formReady" class="btn btn-success">Send Data</button>
			</form>
			<div v-else>
				<h2>All done!</h2>
				<table class="table table-bordered">
					<tr>
						<td>Name</td>
						<td>{{ fullName }}</td>
					</tr>
					<tr>
						<td>Phone</td>
						<td>{{ user.phone }}</td>
					</tr>
					<tr>
						<td>Email</td>
						<td>{{ user.email }}</td>
					</tr>
					<tr>
						<td>Guests</td>
						<td>
							<ul class="list-group">
								<!-- 1.2.1 А также при выводе в шаблон обращаемся к value. ↑ -->
								<li v-for="guest,i in guests" :key="i" class="list-group-item">
									{{ guest.value }}
								</li>
							</ul>
						</td>
					</tr>
				</table>
			</div>
		</div>
	</div>
	<script>
		Vue.createApp({
			data: () => ({
				user: {
					firstName: '',
					lastName: '',
					phone: '',
					email: ''
				},
				guests: [],
				formDone: false
			}),
			computed: {
				fullName() {
					return (this.user.firstName + ' ' + this.user.lastName).trim()
				},
				formReady() {
					return Object.values(this.user).every(val => val.length > 0)
				}
			},
			methods: {
				// * 3.0 Теперь немного о асинхронности в Vue. Когда мы меняем данные, например пушим нового гостя при помощи метода "addGuest", то процесс обновления шаблона идёт асинхронно. Т.е. Vue будет ждать завершения этой функции и только когда все изменения на уровне данных произошли, запустится процесс обновления с хуками «beforeUpdate» & «updated» и там у нас нет точки в коде, где можно дождаться новой версии системы. Поэтому можно увидеть побочные эффекты при усложнении задачи. Вот, например мы хотим продолжить тему работы с ref’ами. ↑
				// 3.3 В методе addGuest обращаемся через объект $refs к последнему инпуту и ставим на нём фокус методом focus. Но мы сталкиваемся с ошибкой, выглядит, как будто рендеринг не поспевает и на одно мгновенье запаздывает, в итоге наш код не находит нужный инпут.
				// ? 3.4.0 Забавный факт, что если выводить в консоль this.$refs, то снаружи мы видим всегда на 1 инпут меньше, чем, если мы раскроем детали и посмотрим внутрь. Так происходит из-за особенностей работы браузера, который отобразил сперва информацию на момент опроса массива, а уже внутри показывает актуальную информацию, т.е. на момент, когда мы её смотрим и следовательно последний инпут успел отрендерится.
				addGuest() {
					// 1.1 Для начала заменим добавление в массив обычной пустой строки на добавление объекта с пустой строкой в виде значения.
					// this.guests.push('')
					this.guests.push({ value: '' })

					// this.$refs.guests.focus()
					// console.log(this.$refs);
					// 3.4.1 Также вызывая в консоль "this.$refs.guests" мы видим, что на момент вызова у нас на уровне данных уже добавлен 1 гость, а на уровне шаблона "undefined", т.е. ещё не отрендерился. Добавляем второго: на уровне данных 2 гостя, а на уровне шаблона видим 1 инпут и т.д. Vue ждёт завершения работы всех функций и только тогда обновляет результат и при обновлении его также обновляется и список ref’ов.
					// 3.4.2 Для начала можно прибегнуть к костыльному решению с помощью setTimeout и это даже будет работать.
					/* setTimeout(() => {
						const guests = this.$refs.guests
						guests[guests.length - 1].focus();
					}, 0); */

					// 3.4.3 Но есть решение куда лучше, во Vue есть специальная команда nextTick, идея которой в том, что мы передаём в коллбэк кусочек кода, который будет выполнен после всех изменений данных в момент полного ререндера шаблона на основе этих данных.
					// ? 3.5 Почему бы не использовать в хуке "updated"? Потому, что в нём мы не будем знать причину обновления компонента, а обновляться он будет при вводе каждой новой буквы в имени гостя и запускать наш код, а нам такое поведение совсем не нужно.
					// Go to [vue-3-course\02\05-classes-and-form.html]
					this.$nextTick(() => {
						const guests = this.$refs.guests
						guests[guests.length - 1].focus();
					})
				},
				removeGuest(idx) {
					this.guests.splice(idx, 1)
				},
				sendForm() {
					if (this.formReady) this.formDone = true
					// 1.2.0 Естественно нам теперь нужно исправить кое-где код. ↑
					this.guests = this.guests.filter(guest => guest.value.length > 0)
				}
			},
			// 2.2 И вот мы подошли к теме жизненных циклов компонента. Мы пропишем новую секцию "mounted", а в ней обратимся к объекту $refs, найдём созданную выше ссылку на первый инпут и применим к нему "focus", т.о. этот инпут будет сфокусирован при загрузке страницы.
			/* ? 2.3 Что происходит, когда система получает от нас команду отрендерить компонент и занимается его созданием? У всех компонентов Vue есть некие моменты, они же жизненные циклы, на которые мы можем подписаться:
				* 1) beforeCreate - перед созданием компонента;
				* 2) created - после создания компонента;
				* 3) beforeMount - перед монтированием;
				* 4) mounted - когда смонтирован;
				* 5) beforeUpdate - перед обновлением;
				* 6) updated - когда обновлён;
				* 7) beforeUnmount - в момент планирования того, что компонент уберут из DOM;
				* 8) unmounted - когда компонент удалён из DOM. */
			// ? 2.4 Сперва запускается "beforeCreate", и на самом деле сложно придумать для него применение, т.к. он запускается, когда в компоненте ещё ничего не успело произойти, и потому, как он практически для всех задач слишком рано, то он остаётся по сути таким загадочным резервным хуком.
			// 2.5 Далее у нас инициализируется система реактивности, т.е. во Vue 2 это обработка каждого поля и создание для него геттера и сеттера, а для Vue 3 это создание Proxy объектов. И после запускается хук "created". Этот хук уже посерьёзнее, с ним уже будем часто работать, потому, что мы уже имеем какие-то данные. Часто его используют, например, для создания запроса на сервер за данными. Например, есть карточка товара, которая получила id, и по этому id мы хотим с сервера получить товар. Но сам элемент ещё не отображён, поэтому что-то делать с объектом DOM, как например ref поставить здесь ещё рано.
			// 2.6 Дальше происходит компиляция шаблона, который у компонента описал, либо секцией "template", либо берётся из вёрстки.
			// 2.7 Далее идёт работа хука "beforeMount", когда шаблон полностью готов, но в вёрстке ещё не появился. Он также редко используется.
			// 2.8 А вот хук "mounted" уже очень важный, т.к. произошёл рендер всех элементов компонента и он вставлен в вёрстку и готов к работе.
			// 2.9 Хуки "beforeUpdate" & "updated" соответственно срабатывают перед и после обновления данных компонента.
			// 2.10 А "beforeUnmount" & "unmounted" соответственно будут запущены в самом конце. Кстати, во Vue 2 они назывались "beforeDestroy" & "destroyed". Поэтому при переходе на Vue 3 код с этими хуками мог сломаться.
			// 2.11 Реально популярных хуков 2: "created" & "mounted". "created" для операций, основанных на данных, чаще всего это запросы к серверу за новыми ресурсами, а "mounted" это доработка шаблона поверх Vue, например, это применение сторонних библиотек, ну или др. действия вроде фокусировки полей или другие действия через refs. ↑
			mounted() {
				this.$refs.firstInput.focus()
			}
		}).mount('.sample');
	</script>
</body>

</html>