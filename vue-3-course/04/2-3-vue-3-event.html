<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>1</title>
	<link rel="stylesheet" href="../../../../vendor/css/font-awesome.min.css">
	<link href="../../../../vendor/css/bootstrap.min.css" rel="stylesheet">
	<link href="../../../../vendor/css/style.css" rel="stylesheet">
	<script src="../../../../vendor/js/vue.global.js"></script>
</head>
<!-- * 2.0 В течении этого курса стараемся делать так, чтобы всё работало и во Vue 2 и во Vue 3. А сейчас будет немного про различия подходов. ↓ -->

<body>
	<div class="wrapper">
		<div class="sample">
			<form>
				<div class="progress" role="progressbar" aria-label="Fields filled progress" aria-valuenow="25"
					aria-valuemin="0" aria-valuemax="100">
					<div class="progress-bar" :style="progressStyles"></div>
				</div>
				<div class="my-3">
					<!-- 2.1.0 Что же будет, если мы вместо кастомного события "updated" подпишемся на событие "input"? Получаем ошибку: "Uncaught TypeError: val.trim is not a function..." Давайте разбираться, во-первых перейдём к методу onUpdate... ↓ -->
					<!-- ? 2.1.2 Почему же так происходит? Vue 3 пытается нам помочь и она нативные ивенты, которые произошли в дочернем элементе переносит на уровень родительского элемента. -->
					<!-- ? 2.1.3 Во Vue 2 схема была простая: есть родительский и дочерний компонент. Дочерний получает от родительского пропсы, и только на то, что дочерний эмитом выбрасывает наружу, только на это можно подписаться через "@..." в родительском. И почему же во Vue 3 решили эту простую и надёжную схему изменить? Когда создаются UI-библиотеки, где нужно сделать, например, свою умную обёртку над инпутом, то всегда дико неудобно передавать в этот инпут стандартные теги и подписываться на стандартные ивенты. Ведь, чтобы создать в UI-библиотеке тег, к примеру "<CleverInput />", который будет воспроизводить тег <input> с какими-то доработками нужно прописать все пропсы, которые <input> может принять согласно стандартам W3C и эти пропсы в input’е вручную распечатать. И чтобы человек мог подписываться на события изменения этого инпута: "click", "focus", "blur", "focusin", "focusout", "mouseenter" и т.д. Мы должны на уровне ребёнка на них подписаться и по каждому нативному делать эмит наверх. И проблемой это является именно, когда мы на уровне UI-библиотеки/фреймворка описываем теги, стараемся сделать их умнее. А в других случаях это не является проблемой ни в коей мере. -->
					<!-- ? 2.1.4 И вот что сделали во Vue 3: то, что мы пропишем как стандартные атрибуты, совпадающие с классическими названиями — портируется на корневой узел дочернего компонента. События, происходящие на дочерних тегах дочернего комп. сначала обрабатываются внутри этого элемента, но если он никакие правила дополнительные не прописал, то они вылетают на уровень вверх. Т.е. мы получим аналог всплытия событий нативного JS. Т.е. события, произошедшие внутри обычного компонента, обычные события DOM могут оказаться на уровне родителя. -->
					<!-- ? 2.1.5 Но почему происходит ошибка, когда вызываем здесь событие "input"? Потому, что запускается наш обработчик, где мы эмитируем "input" на уровень родителя и первый раз срабатывает «@updated="onUpdate(i, $event)"»... ↓ -->
					<!-- ? 2.1.7 ... приходит сюда. А сюда приходит не тот ивент, т.к. ... ↓ -->
					<!-- 3.1.1 ... который знает, что $event принимает объект и можно дописать ему ".target.value". Т.е. ребёнок больше не делает доп. события "input". ↓ -->
					<!-- * 4.0.0 Но представим ситуацию, когда стоит задача событие именно назвать "input", а нам мешает нативный всплывающий инпут. Для этого во Vue 3 есть механика валидации ивентов перед их отправкой наверх. ↓ -->
					<app-input v-for="input,i in info" :key="i" :label="input.label" :value="input.value" :valid="input.valid"
						@updated="onUpdate(i, $event.target.value)" />
				</div>
				<button class="btn btn-primary" :disabled="!isFormReady">
					Отправить Данные
				</button>
			</form>
			<pre>
				{{ info }}
			</pre>
			<div>
				<table class="table table-bordered">
					<tr>
						<td></td>
						<td></td>
					</tr>
				</table>
			</div>
		</div>
	</div>
	<script>
		const AppInput = {
			props: {
				label: { type: String, required: true },
				value: { type: String, required: true },
				valid: { type: Boolean, required: true },
			},
			// 4.0.1 Есть специальный раздел "emits", который специально для этого прописывается. И логика здесь такая: прописываем название ивента и функцию-валидатор, которая будет возвращать true/false, надо посылать это событие вверх или нет. Можно вписать "null" — это будет значит, что событие нативное посылаться вверх больше не станет.
			emits: {
				input: null
			},
			data() {
				return {
					activated: this.value !== ''
				}
			},
			// 2.1.8 ...т.к. здесь мы прокидывали только evt.target.value. Поэтому в нативном ивенте всегда идёт сам объект этого ивента.
			// * 3.0 Итак, что мы можем сделать во Vue 3. Мы больше не эмитируем этот ивент вручную.
			// 3.1.2 Мы полностью отказались от эмита в ребёнке и в инпут приходит нативное событие "input".
			// ? 3.2 Насколько это выгодно сказать сложно: Когда мы создаём дочерние компоненты мы прописывая их ивенты ориентированы не на стандартные ивенты DOM происходящие в них, мы их переделываем в смысловую составляющую. Например, есть компонент модального окна и он принимает параметр show, content, какие-то доп. настройки и он отбрасывает не события click, а родителю он отбрасывает "onOk" (юзер подтвердил что-то), "onClose" (юзер кликнул на "Х" кнопку закрытия или на кнопку "cancel"). Т.е. события дочернего компонента в адрес родительского это осмысленные события: мы видим, что у ребёнка произошёл клик, мы поняли куда клик произошёл, почему и отправили информацию родителю что этот клик должен означать. А когда мы здесь создаём такие вот небольшие обёртки над обычными тегами, то можно сделать и такую вот схему, где ребёнок вообще не перерабатывает событие отправляемое в адрес родителя. Тем не менее пока лучше сосредоточиться на схеме, рассмотренной в примере №1 [vue-3-course\03\homework-3\master-example\0-hw_form.html]. Потому, что всё это новшества Vue 3 и наибольшую выгоду из них могут извлечь создатели UI-библиотек, а при написании обычного кода не даёт такой уж заметной выгоды.
			methods: {
				onInput(evt) {
					this.activated = true
					// this.$emit('updated', evt.target.value)
				}
			},
			// ? 2.1.6 ...но сразу после этого система видит, что здесь было совершено событие "input" и посылает это нативное событие на верхний узел. Получается генерируется событие с название "input"... ↑
			// 3.1.0 Мы понимаем, что этот инпут выбросится на уровень родителя. Здесь мы его оставим, чтобы поле сделать активным "this.activated = true". Но тогда можно добавить модификатор "once". Но так случившийся input как само событие оно всплывёт на уровень родителя... ↑
			template: `
				<div class="form-group">
					<label>
						{{ label }}
						<span v-if="activated" :class="valid ? 'fa fa-check-circle text-success' : 'fa fa-exclamation-circle text-danger'"></span>
					</label>
					<input type="text" class="form-control" :value="value" @input.once="onInput">
				</div>
			`
		}

		Vue.createApp({
			components: {
				AppInput
			},
			data: () => ({
				info: [
					{
						label: 'Name',
						value: '',
						pattern: /^[a-zA-Z ]{2,30}$/
					},
					{
						label: 'Phone',
						value: '+',
						pattern: /^\+{1}[0-9]{11}$/
					},
					{
						label: 'Email',
						value: '',
						pattern: /.+/
					},
					{
						label: 'Some Field 1',
						value: '',
						pattern: /.+/
					},
					{
						label: 'Some Field 2',
						value: '',
						pattern: /.+/
					}
				]
			}),
			computed: {
				fieldsDone() {
					return this.info.filter(field => field.valid).length
				},
				progressStyles() {
					return { width: (this.fieldsDone / this.info.length) * 100 + '%' }
				},
				isFormReady() {
					return this.fieldsDone >= this.info.length
				}
			},
			// 2.1.1 ...и выведем "val" в консоль, чтобы посмотреть что туда попадёт. И мы заметим, что если события у нас "updated", то мы получаем как и ожидали введённые в строку данные, а если "input", то "val" будет равен нативному input ивенту и поэтому браузер ругается, что он не функция. ↑
			methods: {
				onUpdate(i, val) {
					console.log(val);
					const field = this.info[i]
					field.value = val.trim()
					field.valid = field.pattern.test(field.value)
				}
			},
			created() {
				this.info.forEach(field => {
					field.valid = false
					field.activated = false
				})
			}
		}).mount('.sample')
	</script>
</body>

</html>