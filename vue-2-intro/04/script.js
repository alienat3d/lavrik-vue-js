// 1.4 Чтобы создать какой-то Vue-компонент мы пропишем Vue.component. Первым параметром он примет название компонента, который мы хотим создать, в нашем случае "app-progress", а вторым примет объект и он похож на объект Vue, который был у нас раньше, но с рядом отличий. Во-первых, компонент не работает ни с каким элементом, но у него должно быть поле "template", где мы опишем что из себя компонент представляет и какие элементы должны быть расположены внутри него (у нас тут будет прогрессбар от Bootstrap).
// 1.5 Теперь у нас глобально зарегистрирован новый компонент и это значит, что мы можем его использовать внутри любого элемента. Идея компонента заключается, что мы теперь можем в вёрстке писать имя компонента, будто бы это HTML-тег и вместо него будет подставляться содержимое его template. Разумеется этот template может быть сформирован динамически и в нём могут быть использованы все те же приёмы, как и во время создания обычного экземпляра Vue.
// * 2.0 Теперь подумаем, что нужно ещё добавить нашему компоненту прогрессбара. Логично предположить, что ему нужно менять свою ширину и для этого ему нужно передавать параметр "width". Но это неудобно, т.к. его придётся рассчитывать в коде. А чтобы было удобно нужно перенести этот расчёт внутрь компонента. Ведь что такое прогрессбар — это элемент, который показывает сколько шагов из максимального кол-ва мы уже прошли. Итак мы добавим props и поместим туда два параметра: 1) макс. кол-во шагов, 2) текущее значение. Укажем значением им тип данных "Number". По сути это значит, что при создании этого компонента он теперь ожидает два числа в виде атрибутов, если сравнивать с HTML-тегами "max" & "val".
// 2.1 Далее нам понадобится применить вычисляемые данные "computed", где мы рассчитаем текущую ширину прогрессбара разделив текущее значение "val" на максимальное "max" и умножив на 100.
Vue.component('app-progress', {
	props: {
		max: Number,
		val: Number
	},
	computed: {
		width() {
			let w = this.val / this.max * 100;

			// 2.4 Чтобы исправить баг, когда прогрессбар становится более 100% или менее 0, нужно прописать пару условий. ↓
			if (w > 100) {
				w = 100;
			}
			else if (w < 0) {
				w = 0;
			}

			return {
				width: w + '%'
			}
		}
	},
	// 2.2 Далее мы будем динамически генерировать стиль width, исходя из расчётов "width()"
	template: `
		<div class="progress">
			<div class="progress-bar" v-bind:style="width"></div>
		</div>
	`
});

// 2.3.0 Осталось добавить изменения параметром "val" & "max" в родительском элементе, а для этого добавим в data "maxNumbers"...
let sample = new Vue({
	el: '.sample',
	data: {
		showRes: true,
		numbers: [],
		maxNumbers: 10
	},
	methods: {
		addNumber() {
			// 2.6.1 И здесь уже проверим, если done возвращает false, то генерируем число и добавляем в массив numbers.
			// Go to [vue-2-intro\04\index.html]
			if (!this.done) {
				let rnd = Math.floor(Math.random() * 11) - 5;
				this.numbers.push(rnd);
			}
		}
	},
	computed: {
		sum() {
			let sum = 0;

			for (let i = 0; i < this.numbers.length; i++) {
				sum += this.numbers[i];
			}

			return sum;
		},
		btnText() {
			return this.showH2 ? 'Hide result' : 'Show result';
		},
		// 2.6.0 Также нам бы хотелось, чтобы при достижении прогрессбаром 100% кнопка "добавить число" блокировалась и больше чисел не было бы возможным добавлять. И теперь мы можем ориентироваться на это поле "done" как внутри кнопки, так и внутри метода. ↑
		done() {
			return this.numbers.length >= this.maxNumbers;
		}
	}
});